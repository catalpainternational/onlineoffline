// Generated by CoffeeScript 1.10.0

/*
RequestStore
  Provides a riotjs store to hold/inspect request information before it is passed to the server, and
  store results afterwards
 */

(function() {
  window.RequestStore = function() {
    var getCookie, getCsrftoken, self;
    riot.observable(this);
    self = this;
    self.requests = [];

    /* Read the current csrf token */
    getCookie = function(name) {
      var cookie, cookieValue, cookies, i;
      cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        cookies = document.cookie.split(';');
        i = 0;
        while (i < cookies.length) {
          cookie = jQuery.trim(cookies[i]);
          if (cookie.substring(0, name.length + 1) === name + '=') {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
          i++;
        }
      }
      return cookieValue;
    };
    getCsrftoken = function() {
      return getCookie('csrftoken');
    };

    /* Shelve / unshelve requests to local storage to persist them through a browser restart
      TODO: Make this work with Lawnchair not just localstorage
     */
    self.on('shelve_requests', function() {
      return localStorage.setItem('requests', JSON.stringify(self.requests));
    });
    self.on('unshelve_requests', function() {
      self.requests = JSON.parse(localStorage.getItem('requests')) || [];
      return RiotControl.trigger('requests_changed', self.requests);
    });
    self.on('requests_init', function() {
      self.trigger('requests_changed', self.requests);
    });
    self.on('request_remove', function(e) {
      var i;
      i = self.requests.length - 1;
      while (i >= 0) {
        if (self.requests[i] === e.item) {
          self.requests.splice(i, 1);
        }
        i--;
      }
      return RiotControl.trigger('requests_changed', self.requests);
    });
    self.on('request_add', function(request) {
      self.requests.push({
        'url': request.url,
        'method': request.method,
        'data': request.data,
        'status': request.status,
        'done': request.done,
        'appName': request.appName,
        'modelName': request.modelName,
        'modelPk': request.modelPk,
        'action': request.action,
        'fail': request.fail || 'request_failed'
      });
      return RiotControl.trigger('requests_changed', self.requests);
    });
    self.on('request_update', function(item, xhr) {
      item.status = parseInt(xhr.status);
      return self.trigger('requests_changed', self.requests);
    });

    /* Attempt to send our request to the server */
    self.on('request_do', function(request) {
      var headers, xhr;
      headers = {
        'Accept': 'application/json; q=1.0, */*',
        'X-CSRFToken': getCsrftoken()
      };
      xhr = $.ajax({
        url: request.url,
        method: request.method,
        data: request.data,
        contentType: 'application/json',
        processData: false,
        headers: headers
      });

      /* Always update our riotjs store instance with the response code */
      xhr.done(function(data, textStatus, jqXHR) {
        if ($.isFunction(request.done)) {
          console.error('This will break localstorage for requests!');
          request.done(data, textStatus, jqXHR);
        }
        if (typeof request.done === 'string') {
          return RiotControl.trigger(request.done, data, textStatus, jqXHR, request);
        }
      });

      /* Always update our riotjs store instance with the response code */
      xhr.always(function(data, textStatus, jqXHR) {
        RiotControl.trigger('request_update', request, jqXHR);
        return RiotControl.trigger('requests_changed', self.requests);
      });
      return xhr.fail(function(jqXHR, textStatus, errorThrown) {
        return RiotControl.trigger(request.fail, request, jqXHR, textStatus, errorThrown);
      });
    });

    /* Adding a new model to the DRF */
    self.on('model_add', function(modelData, appName, modelName, done) {
      var url;
      url = '/' + appName + '/api/' + modelName + '/';
      return RiotControl.trigger('request_add', {
        'url': url,
        'method': 'POST',
        'data': modelData,
        'done': done
      });
    });

    /* Prepare a request to delete a model instance through DRF */
    self.on('model_remove', function(appName, modelName, modelPk, done) {
      var url;
      url = '/' + appName + '/api/' + modelName + '/' + modelPk + '/';
      return RiotControl.trigger('request_add', {
        'url': url,
        'method': 'DELETE',
        'data': '',
        'done': done,
        'modelPk': modelPk,
        'modelName': modelName,
        'appName': appName
      });
    });

    /* Prepare a request to update a model instance through DRF */
    return self.on('model_update', function(modelData, appName, modelName, modelPk, done, opts) {
      var url;
      url = '/' + appName + '/api/' + modelName + '/' + modelPk + '/';
      return RiotControl.trigger('request_add', {
        'url': url,
        'method': 'PUT',
        'data': modelData,
        'done': done,
        'modelPk': modelPk,
        'modelName': modelName,
        'appName': appName
      });
    });
  };

}).call(this);
