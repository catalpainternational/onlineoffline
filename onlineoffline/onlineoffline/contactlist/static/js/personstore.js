// Generated by CoffeeScript 1.10.0

/*
  PersonStore: Provides add, edit, remove model functionality through the RequestStore
 */

(function() {
  var appName, modelName;

  modelName = 'person';

  appName = 'contactlist';

  window.PersonStore = function(persons) {
    var self;
    riot.observable(this);
    self = this;
    self.persons = persons || [];
    self.edit = {};
    self.on('persons_reload_from_server_done', function(data, textStatus, jqXHR) {
      self.persons = data.results;
      self.trigger('persons_changed', self.persons);
    });

    /* Request the latest person list from DRF */
    self.on('reload_from_server', function() {
      var request;
      request = {
        'url': "/" + appName + "/api/" + modelName + "/?format=json",
        'method': 'GET',
        'data': '',
        'status': 0,
        'done': 'persons_reload_from_server_done',
        'action': 'immediate'
      };
      return RiotControl.trigger('request_add', request);
    });

    /* Save the current state of persons to 'Lawnchair' for offline storage */
    self.on('save_to_local', function() {
      return Lawnchair({
        name: 'persons'
      }, function(store) {
        var indexof, p, results;
        store.nuke();
        results = [];
        for (indexof in self.persons) {
          p = self.persons[indexof];
          results.push(store.save({
            key: p.id,
            data: p
          }));
        }
        return results;
      });
    });

    /* Load the current state of persons saved in Lawnchair */
    self.on('from_local', function() {
      self.persons = [];
      return Lawnchair({
        name: 'persons'
      }).all(function(store) {
        var indexof;
        for (indexof in store) {
          self.persons.push(store[indexof].data);
        }
        return self.trigger('persons_changed', self.persons);
      });
    });
    self.on('person_init', function() {
      return self.trigger('persons_changed', self.persons);
    });
    self.on('person_add_done', function(data, textStatus, jqXHR) {
      self.persons.push(data);
      return self.trigger('persons_changed', self.persons);
    });
    self.on('person_add', function(newPerson) {
      return RiotControl.trigger('model_add', newPerson, 'contactlist', 'person', 'person_add_done');
    });
    self.on('person_remove_done', function(data, textStatus, jqXHR, request) {
      var i, results;
      i = self.persons.length - 1;
      results = [];
      while (i >= 0) {
        if (self.persons[i].id === request.modelPk) {
          self.persons.splice(i, 1);
          self.trigger('persons_changed', self.persons);
        }
        results.push(i--);
      }
      return results;
    });
    self.on('person_remove', function(e) {
      return RiotControl.trigger('model_remove', appName, modelName, e.item.id, 'person_remove_done');
    });
    self.on('person_edit_done', function(data, textStatus, jqXHR, request) {
      var i, results;
      i = self.persons.length - 1;
      results = [];
      while (i >= 0) {
        if (self.persons[i].id === request.modelPk) {
          self.persons[i] = data;
        }
        self.trigger('persons_changed', self.persons);
        results.push(i--);
      }
      return results;
    });
    return self.on('person_edit', function(e, item) {
      var form, newPerson, obj;
      form = $(e.currentTarget);
      obj = {};
      $.map(form.find('input, textarea').not('[name=csrfmiddlewaretoken],[type=submit]'), function(n, i) {
        return obj[n.name] = $(n).val();
      });
      newPerson = JSON.stringify(obj);

      /* Trigger a model_update from RequestStore to post this, or cache it */
      return RiotControl.trigger('model_update', newPerson, appName, modelName, item.id, 'person_edit_done');
    });
  };

}).call(this);
